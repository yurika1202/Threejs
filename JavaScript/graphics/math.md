## 弧度法（ラジアン）

- 円周の長さを基準とした角度の表現
- 360 度＝円周率(π)×2（＝約 6.28）
- 円の半径に等しい長さの弧を 1 ラジアンとしたもの、ともいえる（1 ラジアン＝半径）

```
// ラジアン変換
function degToRad(degrees) {
  return (degrees / 360) * (Math.PI / 180);
}

// 最適化
function degToRad(degrees) {
  return degrees * Math.PI / 180;
}
```

## sin と cos

- 半径 1 の円を基準として、ある点 P の座標は(cosθ, sinθ)となる
- sin や cos の値は常に-1 ～ 1 の範囲に収まる
- 半径が 1 でない円で求める場合には、その半径の値をそのまま sin や cos の値に乗算することで縦横それぞれの長さを計算できる

ex. 基準点 A の座標(x, y)から θ の方向へｒ移動した位置 B の座標(x', y')を求める

```
let A = [0.0, 0.0];
let radian = degToRad(theta);
let sin = Math.sin(radian);
let cos = Math.cos(radian);
let B = [
  A[0] + cos * r,
  A[1] + sin * r
];
```

## ベクトル

- 「量」に「向き（方角）」という概念が加わったもの
- 始点と終点の各座標が分かればベクトルを表現できる
- 「終点 - 始点」で数値の組み合わせ(x, y)として表現できる
- 暗黙的に始点が原点とされる場合も多々

### ベクトルの向き

- 単位化（大きさを 1 に揃えること）することで向きだけに焦点をあてられる
- 例えば「向きに関する計算を行う」、「向きだけを比較したい」など…

```
let a = [5, -3];

// ベクトルの大きさ
let l = Math.sqrt(a[0] * a[0] + a[1] * a[1]);

// ベクトルの単位化
a[0] /= l;
a[1] /= l;

console.log(a); // [0.857..., -0.514...]
```

- ベクトルの大きさは、ベクトルを構成する各要素ごとに乗算したあと合算して平方根をとる（Math.sqrt）
- 求めたベクトルの大きさで各要素を除算すると、単位化されたベクトルになる（＝単位ベクトル）
- 値の範囲は-1 ～ 1 の範囲内に収まる
- ベクトルの成す角度＝単位化した任意のベクトルをアークサイン(Math.asin)やアークコサイン(Math.acos)に与える

### ベクトルの演算

- 計算結果として「同じ次元のベクトル」が得られる
- ふたつのベクトルを繋ぎ合わせたように表し、最終的にベクトルの先端が指し示す座標へと伸びる新たなベクトルが定義される。

```
let V = [5, -3];
let W = [-2, 6];

// 加算
let A = [
  V[0] + W[0],
  V[1] + W[1]
]
console.log(A); // [3, 3]

// 減算
let S = [
  V[0] - W[0],
  V[1] - W[1]
]
console.log(S); // [7, -9]
```

- ベクトルには乗算と除算の計算方法はないが、「スカラー倍（定倍数）」というベクトルとスカラーの値をかけ合わせて拡大縮小する方法がある
- あるオブジェクトの移動速度はこのスカラー倍によって変化させることができる

```
let V = [5, -3];
let scalar = 2.0; // スケールするためのスカラー定義

let W = [
  V[0] * scalar,
  V[1] * scalar
];
console.log(W); // [10, -6]
```

- 内積：ベクトル A とベクトル B の成す角 θ に対する cos
- ベクトルの各要素同士を掛け合わせたあと、すべてを合算する
- 次元の異なるベクトル同士では内積計算はできない

```
function dot(v0, v1) {
  return v0[0] * v1[0] + v0[1] * v1[1];
}
```

- 単位化したベクトルの内積の結果は内積の性質上 cosθ と等しくなるため、角 θ を求めるにはアークコサインを用いることで求めることができる

```
let V = [5, 1];
let W = [-2, 3];

// ベクトルの単位化
V = normalize(V);
W = normalize(W);

// 単位化したベクトルの内積を求める
let dotValue = dot(V, W);

// アークコサインでラジアンを求める
let rad = Math.acos(dotValue);

// ラジアンから度数へ変換
let deg = rad / Math.PI * 180;

console.log(rad); // 1.1961...
console.log(deg); // 112.3801...

// ベクトルを単位化する関数
function normalize(v) {
  // (x * x + y * y)の平方根を求める＝ベクトルの長さ
  let len = Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  return [v[0] / len, v[1] / len];
}

// ベクトルの内積を求める関数
function dot(v0, v1) {
  return (v0[0] * v1[0] + v0[1] * v1[1])
}
```

- 外積：ベクトル A とベクトル B の成す角 θ に対する sin
- 2 次元ベクトル同士の結果はスカラー、3 次元同士の結果は 3 次元ベクトル
- 3 次元ベクトルはベクトル A とベクトル B に直交するベクトル C を求めることになり、これはある平面からまっすぐ上に伸びるベクトルを求めてその向きに応じて照度を計算するなどの用途で使われる
- 平面に対して水平なベクトルを 2 つ定義できていれば、平面に直交するベクトルを求められる

```
function cross(v0, v1) {
  return [
    v0[1] * v1[2] - v0[2] * v1[1], // y0 * z1 - z0 * y1
    v0[2] * v1[0] - v0[0] * v1[2], // z0 * x1 - x0 * z1
    v0[0] * v1[1] - v0[1] * v1[0], // x0 * y1 - y0 * x1
  ]
}
```

- 2 次元の場合(x, y, 0)の 3 次元ベクトルとして計算していることと同意味なので上記のコードに当てはめると最下部以外は 0 になり、スカラー値を求める計算と同じになるため 2 次元ベクトルの外積結果はスカラーとなる

| 単位     | 使いどころ                         |
| -------- | ---------------------------------- |
| コサイン | 左右の方向、もしくは垂直を判定する |
| サイン   | 上下の方向、もしくは水平を判定する |

| ベクトルの要点         | 結果                                           |
| ---------------------- | ---------------------------------------------- |
| 単位ベクトル同士の内積 | コサイン                                       |
| 単位ベクトル同士の外積 | サイン                                         |
| 内積=0                 | ベクトル同士は垂直である                       |
| 内積が正の値           | 両者の成す角は鋭角である                       |
| 内積が負の値           | 両者の成す角は鈍角である                       |
| 外積=0                 | ベクトル同士は水平である                       |
| 外積が正の値           | ベクトル A からみて上（左）にベクトル B がある |
| 外積が負の値           | ベクトル A からみて下（右）にベクトル B がある |

### 行列

- ベクトルを変形・変換する時に用いる
- 数値を行や列で区切ってひとまとまりにしたもので、行と列の数はさまざまである
- 2D グラフィックスでは 2\*2 の正方行列がよく用いられる
- 正方行列内にサインとコサインの結果を配置することでベクトルを回転させる回転行列を定義でき、これは 2 次元ベクトルと乗算を行うことができる

```
/*
vec：回転させるベクトル
radian：回転量を表すラジアン
*/

function rotate2D(vec, radian) {
  let sin = Math.sin(radian);
  let cos = Math.cos(radian);

  return [
    vec[0] * cos + vec[1] - sin,
    vec[0] * sin + vec[1] * cos
  ]
}
```

## 乱数と疑似乱数

- 乱数とはランダムな値のことであり、コンピュータが生成する乱数は疑似乱数という
- JS では `Math.random` を利用して、0 以上 1 未満の浮動小数点の値を乱数生成する
- もし範囲が 0 以上 1 未満だと足りない場合は、乱数の結果に対して定数を掛けることで可能
- 整数で乱数を扱いたい場合には、範囲を拡大したうえで`Math.floor`などで小数点の切り捨て処理を行う

```
// 0以上100未満の乱数の生成

function rnd() {
  let random = Math.random();

  // 定数倍
  random *= 100;

  // 小数点以下の切り捨て
  return Math.floor(random);
}
```

- 乱数の元になる値のことをシード値といい、シード値から得られる乱数列は同じものになる＝シード値が同じならば生成される乱数は毎回同じ
- JS はシード値に時間を利用しているため、シード値が同じになることはない
- もしもシード値を指定したいならば、乱数生成の仕組みそのものを独自実装する必要がある

## イージング

- 補間関数の引数には 0.0 ～ 1.0 の範囲の値を与え、戻り値も 0.0 ～ 1.0 で返される
  |名前|コード|
  |---|---|
  |linear|function(t) {return t;}|
  |easeInQuad|function(t) {return t _ t;}|
  |easeOutQuad|function(t) {return t _ (2 - t);}|
  |easeInOutQuad|function(t) {return t < 0.5 ? 2 _ t _ t : -1 + (4 - 2 _ t) _ t;}|
